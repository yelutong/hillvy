2.克隆
function clone(obj) { 
    var o; 
    switch (typeof obj) { 
        case "undefined": 
            break; 
        case "string": 
            o = obj + ""; 
            break; 
        case "number": 
            o = obj - 0; 
            break; 
        case "boolean": 
            o = obj; 
            break; 
        case "object": // object 分为两种情况 对象（Object）或数组（Array） 
            if (obj === null) { 
                o = null; 
            } else { 
                if (Object.prototype.toString.call(obj).slice(8, -1) === "Array") { 
                    o = []; 
                    for (var i = 0; i < obj.length; i++) { 
                        o.push(clone(obj[i])); 
                    } 
                } else { 
                    o = {}; 
                    for (var k in obj) { 
                        o[k] = clone(obj[k]); 
                    } 
                } 
            } 
            break; 
        default: 
            o = obj; 
            break; 
    } 
    return o; 
}

4、想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）。 

注意： 为了让元素可拖动，需要使用 HTML5 draggable 属性。 

提示： 链接和图片默认是可拖动的，不需要 draggable 属性。 

在拖放的过程中会触发以下事件： 

在拖动目标上触发事件 (源元素): 
ondragstart - 用户开始拖动元素时触发 
ondrag - 元素正在拖动时触发 
ondragend - 用户完成元素拖动后触发 

释放目标时触发的事件: 
ondragenter - 当被鼠标拖动的对象进入其容器范围内时触发此事件 
ondragover - 当某被拖动的对象在另一对象容器范围内拖动时触发此事件 
ondragleave - 当被鼠标拖动的对象离开其容器范围内时触发此事件 
ondrop - 在一个拖动过程中，释放鼠标键时触发此事件 
 <!DOCTYPE HTML> 
<html> 
<head> 
<meta charset="utf-8"> 
<title>ondrag相关事件</title> 
<style> 
.droptarget { 
    float: left; 
    width: 100px; 
    height: 35px; 
    margin: 15px; 
    padding: 10px; 
    border: 1px solid #aaaaaa; 
} 
</style> 
</head> 
<body>                                                                                                                                                                        <p>在两个矩形框中来回拖动 p 元素:</p> 
<div class="droptarget"> 
	<p draggable="true" id="dragtarget">拖动我!</p> 
</div> 
<div class="droptarget"></div> 
<p style="clear:both;"><strong> 注意：</strong>Internet Explorer 8 及更早 IE 版本或 Safari 5.1 及更早版本的浏览器不支持 drag 事件。</p> 
<p id="demo"></p> 
<script> 
///* 拖动时触发*/ 
document.addEventListener("dragstart", function(event) { 
    //dataTransfer.setData()方法设置数据类型和拖动的数据 
    event.dataTransfer.setData("Text", event.target.id); 
    // 拖动 p 元素时输出一些文本 
    document.getElementById("demo").innerHTML = "开始拖动 p 元素.";    
    //修改拖动元素的透明度 
    event.target.style.opacity = "0.4"; 
}); 
//在拖动p元素的同时,改变输出文本的颜色 
document.addEventListener("drag", function(event) { 
    document.getElementById("demo").style.color = "red"; 
}); 
// 当拖完p元素输出一些文本元素和重置透明度 
document.addEventListener("dragend", function(event) { 
    document.getElementById("demo").innerHTML = "完成 p 元素的拖动"; 
    event.target.style.opacity = "1"; 
}); 
/* 拖动完成后触发 */ 
// 当p元素完成拖动进入droptarget,改变div的边框样式 
document.addEventListener("dragenter", function(event) { 
    if ( event.target.className == "droptarget" ) { 
        event.target.style.border = "3px dotted red"; 
    } 
}); 
// 默认情况下,数据/元素不能在其他元素中被拖放。对于drop我们必须防止元素的默认处理 
document.addEventListener("dragover", function(event) { 
    event.preventDefault(); 
}); 
// 当可拖放的p元素离开droptarget，重置div的边框样式 
document.addEventListener("dragleave", function(event) { 
    if ( event.target.className == "droptarget" ) { 
        event.target.style.border = ""; 
    } 
}); 
/*对于drop,防止浏览器的默认处理数据(在drop中链接是默认打开) 
复位输出文本的颜色和DIV的边框颜色 
利用dataTransfer.getData()方法获得拖放数据 
拖拖的数据元素id(“drag1”) 
拖拽元素附加到drop元素*/ 
document.addEventListener("drop", function(event) { 
    event.preventDefault(); 
    if ( event.target.className == "droptarget" ) { 
        document.getElementById("demo").style.color = ""; 
        event.target.style.border = ""; 
        var data = event.dataTransfer.getData("Text"); 
        event.target.appendChild(document.getElementById(data)); 
    } 
}); 
</script>                                                                                                                  
</body> 
</html>
